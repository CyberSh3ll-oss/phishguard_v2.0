#!/usr/bin/env python3
"""
PhishGuard GUI — single-file PySide6 application for Linux

Features:
 - Modern, clean Qt-based UI (PySide6)
 - Background scanning with QThreadPool -> keeps UI responsive
 - Blacklist file chooser and normalization
 - Shows score, verdict, indicators, redirect chain, final URL, HTTP status
 - Export report to text file
 - Dark-ish stylesheet and simple animations

Run:
  pip install -r requirements.txt
  python phishguard_gui.py

requirements.txt (suggested):
  PySide6
  requests
  tldextract
  validators

Note: If you prefer PyQt5 replace PySide6 imports accordingly.
"""
from __future__ import annotations
import sys
import os
import re
import ipaddress
import threading
from typing import List, Tuple, Dict, Any
from urllib.parse import urlparse

import requests
import tldextract
import validators

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QLineEdit, QPushButton,
    QTextEdit, QVBoxLayout, QHBoxLayout, QFileDialog, QMessageBox, QProgressBar,
    QListWidget, QListWidgetItem, QTableWidget, QTableWidgetItem, QHeaderView
)
from PySide6.QtCore import Qt, QRunnable, QThreadPool, Signal, QObject, Slot
from PySide6.QtGui import QIcon

# ------------------ Core scanner (improved from your original) ------------------
BLACKLIST_FILE = "blacklist.txt"
TIMEOUT = 6
SUSPICIOUS_KEYWORDS = (
    "login", "secure", "account", "update", "verify",
    "bank", "confirm", "signin", "paypal", "apple", "reset"
)


def normalize_url(u: str) -> str:
    u = (u or "").strip()
    if "://" not in u:
        u = "http://" + u
    return u


def normalize_host(host: str) -> str:
    host = (host or "").lower().strip()
    host = re.sub(r":(80|443)$", "", host)
    return host


def load_blacklist(path: str) -> Tuple[set, set]:
    domains = set()
    fulls = set()
    if not path:
        return domains, fulls
    if not os.path.exists(path):
        return domains, fulls
    with open(path, "r", encoding="utf-8") as f:
        for ln in f:
            ln = ln.strip()
            if not ln or ln.startswith("#"):
                continue
            ln_low = ln.lower()
            if "://" in ln_low:
                fulls.add(normalize_url(ln_low))
            else:
                domains.add(normalize_host(ln_low))
    return domains, fulls


def is_ip_host(host: str) -> bool:
    host = (host or "").split(":")[0]
    try:
        ipaddress.ip_address(host)
        return True
    except Exception:
        return False


def quick_http_info(url: str) -> Tuple[bool, List[str], List[int], str | None]:
    session = requests.Session()
    headers = {"User-Agent": "PhishGuard/1.0"}
    try:
        norm = normalize_url(url)
        try:
            r = session.head(norm, allow_redirects=True, timeout=TIMEOUT, headers=headers, verify=True)
            if r.status_code == 405 or r.status_code == 400:
                r = session.get(norm, allow_redirects=True, timeout=TIMEOUT, headers=headers, verify=True)
        except requests.exceptions.RequestException:
            r = session.get(norm, allow_redirects=True, timeout=TIMEOUT, headers=headers, verify=True)

        chain_urls = [resp.url for resp in r.history] + [r.url]
        chain_status = [getattr(resp, "status_code", None) for resp in r.history] + [r.status_code]
        return True, chain_urls, chain_status, None
    except requests.exceptions.SSLError as e:
        return False, [], [], f"SSL error: {e}"
    except requests.exceptions.Timeout as e:
        return False, [], [], f"Timeout: {e}"
    except requests.exceptions.RequestException as e:
        return False, [], [], f"Request error: {e}"
    except Exception as e:
        return False, [], [], str(e)


def heuristic_score(url: str) -> Tuple[int, List[str]]:
    score = 0
    reasons: List[str] = []
    norm = normalize_url(url)
    parsed = urlparse(norm)
    host = normalize_host(parsed.netloc)
    path = parsed.path or ""
    full = norm.lower()

    if is_ip_host(host):
        score += 30
        reasons.append("Host is an IP address")

    if len(full) > 80:
        score += 8
        reasons.append("URL length > 80")

    for kw in SUSPICIOUS_KEYWORDS:
        if kw in host or kw in path.lower():
            score += 7
            reasons.append(f"Suspicious keyword: '{kw}'")

    if "@" in full:
        score += 15
        reasons.append("Contains '@' (credential-steering trick)")

    extracted = tldextract.extract(host)
    subdomain = extracted.subdomain or ""
    labels = [s for s in subdomain.split(".") if s]
    if len(labels) >= 3:
        score += 5
        reasons.append(f"Many subdomains ({len(labels)} labels) - possible cloak")

    if "//" in path:
        score += 4
        reasons.append("Double slashes in path")

    if host.count("-") >= 3:
        score += 3
        reasons.append("Many hyphens in host")

    return score, reasons


def verdict(score: int) -> str:
    if score >= 40:
        return "PHISHING"
    if score >= 15:
        return "POTENTIALLY DANGEROUS"
    return "SAFE"


def analyze(url: str, blacklist_path: str) -> Dict[str, Any]:
    out: Dict[str, Any] = {"url": url, "score": 0, "indicators": [], "checks": {}}
    domains_bl, fulls_bl = load_blacklist(blacklist_path)

    norm = normalize_url(url)
    parsed = urlparse(norm)
    host = normalize_host(parsed.netloc)
    u_low = norm.lower()

    if host in domains_bl or u_low in fulls_bl:
        out["score"] += 60
        out["indicators"].append("Found in local blacklist")
        out["checks"]["blacklist"] = True
    else:
        out["checks"]["blacklist"] = False

    is_valid = validators.url(norm)
    out["checks"]["valid_url"] = bool(is_valid)
    if not is_valid:
        out["score"] += 6
        out["indicators"].append("Malformed or suspicious URL format")

    ok, chain_urls, chain_statuses, err = quick_http_info(url)
    out["checks"]["http_ok"] = ok
    out["checks"]["redirect_chain"] = chain_urls
    out["checks"]["redirect_statuses"] = chain_statuses
    if not ok:
        out["score"] += 8
        out["indicators"].append(f"Request failed: {err}")
    else:
        final_url = chain_urls[-1]
        final_host = normalize_host(urlparse(final_url).netloc)
        out["checks"]["final_url"] = final_url
        out["checks"]["final_host"] = final_host
        if final_host and final_host != host:
            out["score"] += 6
            out["indicators"].append(f"Redirects to different domain: {final_host}")

        final_scheme = urlparse(final_url).scheme
        if final_scheme != "https":
            out["score"] += 5
            out["indicators"].append("No HTTPS on final URL")

    hscore, hreasons = heuristic_score(url)
    out["checks"]["heuristic_score"] = hscore
    out["checks"]["heuristic_reasons"] = hreasons
    out["score"] += hscore
    out["indicators"].extend(hreasons)

    out["final_verdict"] = verdict(out["score"])
    return out

# ------------------ Worker for background scanning ------------------
class WorkerSignals(QObject):
    finished = Signal(dict)
    error = Signal(str)
    progress = Signal(int)


class ScanWorker(QRunnable):
    def __init__(self, url: str, blacklist_path: str):
        super().__init__()
        self.url = url
        self.blacklist_path = blacklist_path
        self.signals = WorkerSignals()

    @Slot()
    def run(self):
        try:
            # small incremental progress signals for user feedback
            self.signals.progress.emit(10)
            res = analyze(self.url, self.blacklist_path)
            self.signals.progress.emit(100)
            self.signals.finished.emit(res)
        except Exception as e:
            self.signals.error.emit(str(e))

# ------------------ GUI ------------------

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PhishGuard — GUI")
        self.setMinimumSize(900, 600)
        self.threadpool = QThreadPool()
        self._build_ui()
        self.apply_styles()

    def _build_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Top: input and controls
        top = QHBoxLayout()
        self.input_url = QLineEdit()
        self.input_url.setPlaceholderText("Enter URL or domain (e.g. https://example.com/login)")
        top.addWidget(self.input_url)

        self.btn_scan = QPushButton("Scan")
        self.btn_scan.clicked.connect(self.start_scan)
        top.addWidget(self.btn_scan)

        self.btn_choose_bl = QPushButton("Blacklist: default")
        self.btn_choose_bl.clicked.connect(self.choose_blacklist)
        top.addWidget(self.btn_choose_bl)

        layout.addLayout(top)

        # Middle: results grid
        middle = QHBoxLayout()

        left_col = QVBoxLayout()
        self.score_label = QLabel("Score: -")
        self.verdict_label = QLabel("Verdict: -")
        self.verdict_label.setStyleSheet("font-weight: bold; font-size: 18px;")
        left_col.addWidget(self.score_label)
        left_col.addWidget(self.verdict_label)

        self.progress = QProgressBar()
        self.progress.setRange(0, 100)
        left_col.addWidget(self.progress)

        self.indicators_list = QListWidget()
        self.indicators_list.setMinimumWidth(380)
        left_col.addWidget(QLabel("Indicators"))
        left_col.addWidget(self.indicators_list)

        middle.addLayout(left_col)

        right_col = QVBoxLayout()
        self.redirect_table = QTableWidget(0, 2)
        self.redirect_table.setHorizontalHeaderLabels(["URL", "Status"])
        self.redirect_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.redirect_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        right_col.addWidget(QLabel("Redirect chain & statuses"))
        right_col.addWidget(self.redirect_table)

        self.raw_checks = QTextEdit()
        self.raw_checks.setReadOnly(True)
        right_col.addWidget(QLabel("Checks (raw)") )
        right_col.addWidget(self.raw_checks)

        middle.addLayout(right_col)

        layout.addLayout(middle)

        # Bottom: actions
        bottom = QHBoxLayout()
        self.btn_copy = QPushButton("Copy verdict")
        self.btn_copy.clicked.connect(self.copy_verdict)
        bottom.addWidget(self.btn_copy)

        self.btn_open = QPushButton("Open final URL")
        self.btn_open.clicked.connect(self.open_final)
        bottom.addWidget(self.btn_open)

        self.btn_save = QPushButton("Export report")
        self.btn_save.clicked.connect(self.save_report)
        bottom.addWidget(self.btn_save)

        layout.addLayout(bottom)

        # internal state
        self.blacklist_path = BLACKLIST_FILE
        self.current_result: Dict[str, Any] | None = None

    def apply_styles(self):
        # clean, slightly dark stylesheet — modest and modern
        css = """
        QWidget { background: #121212; color: #eaeaea; font-family: 'Segoe UI', Roboto, Sans; }
        QLineEdit, QTextEdit, QListWidget, QTableWidget { background: #1e1e1e; border: 1px solid #2b2b2b; }
        QPushButton { padding: 6px 12px; border-radius: 6px; background: qlineargradient(x1:0,y1:0,x2:0,y2:1, stop:0 #3a3a3a, stop:1 #2a2a2a);} 
        QPushButton:hover { background: #4a4a4a; }
        QProgressBar { background: #151515; border: 1px solid #2b2b2b; text-align: center; }
        QProgressBar::chunk { background: qlineargradient(x1:0,y1:0,x2:0,y2:1, stop:0 #00aeff, stop:1 #0077cc); }
        QLabel { font-size: 13px; }
        """
        self.setStyleSheet(css)

    def choose_blacklist(self):
        path, _ = QFileDialog.getOpenFileName(self, "Choose blacklist file", os.getcwd(), "Text files (*.txt);;All files (*)")
        if path:
            self.blacklist_path = path
            self.btn_choose_bl.setText(f"Blacklist: {os.path.basename(path)}")

    def start_scan(self):
        url = self.input_url.text().strip()
        if not url:
            QMessageBox.warning(self, "Input required", "Please enter a URL or domain to scan.")
            return
        self.progress.setValue(0)
        self.score_label.setText("Score: scanning...")
        self.verdict_label.setText("Verdict: scanning...")
        self.indicators_list.clear()
        self.redirect_table.setRowCount(0)
        self.raw_checks.clear()

        worker = ScanWorker(url, self.blacklist_path)
        worker.signals.finished.connect(self.on_scan_finished)
        worker.signals.error.connect(self.on_scan_error)
        worker.signals.progress.connect(self.progress.setValue)
        self.threadpool.start(worker)

    @Slot(dict)
    def on_scan_finished(self, res: Dict[str, Any]):
        self.current_result = res
        score = res.get("score", 0)
        verdict_text = res.get("final_verdict", "-")
        self.score_label.setText(f"Score: {score}")
        self.verdict_label.setText(f"Verdict: {verdict_text}")

        self.indicators_list.clear()
        for ind in res.get("indicators", []):
            item = QListWidgetItem(ind)
            self.indicators_list.addItem(item)

        chain = res.get("checks", {}).get("redirect_chain", []) or []
        statuses = res.get("checks", {}).get("redirect_statuses", []) or []
        self.redirect_table.setRowCount(len(chain))
        for i, u in enumerate(chain):
            st = str(statuses[i]) if i < len(statuses) else "-"
            self.redirect_table.setItem(i, 0, QTableWidgetItem(u))
            self.redirect_table.setItem(i, 1, QTableWidgetItem(st))

        # pretty raw checks
        import json
        self.raw_checks.setPlainText(json.dumps(res.get("checks", {}), indent=2))
        self.progress.setValue(100)

    @Slot(str)
    def on_scan_error(self, err: str):
        QMessageBox.critical(self, "Scan error", f"An error occurred: {err}")
        self.progress.setValue(0)

    def copy_verdict(self):
        if not self.current_result:
            return
        txt = f"URL: {self.current_result.get('url')}\nScore: {self.current_result.get('score')}\nVerdict: {self.current_result.get('final_verdict')}"
        QApplication.clipboard().setText(txt)
        QMessageBox.information(self, "Copied", "Verdict copied to clipboard.")

    def open_final(self):
        if not self.current_result:
            return
        final = self.current_result.get('checks', {}).get('final_url') or self.current_result.get('url')
        import webbrowser
        webbrowser.open(final)

    def save_report(self):
        if not self.current_result:
            QMessageBox.warning(self, "No result", "Run a scan first to export a report.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Save report", os.path.expanduser("~"), "Text files (*.txt);;All files (*)")
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                import json
                f.write(json.dumps(self.current_result, indent=2))
            QMessageBox.information(self, "Saved", f"Report saved to {path}")
        except Exception as e:
            QMessageBox.critical(self, "Save error", str(e))


# ------------------ Run ------------------

def main():
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
